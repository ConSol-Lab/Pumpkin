* Learned nogood management.
* Restart policy before took into account number of assigned literals, now it might not?
* Implementation of the nogood propagator is basic.
* Implement LBD and activity for nogoods.
* proof logging is done by the nogood propagator?
* Remove allow dead code directives
* Add comments? E.g., the ResolutionNogoodConflictAnalyser uses // but should use ///
* Improve implementation across the board (propagation of nogood? the way they are passed/stored? conflict analysis algorithm?)
* Readd clause minimisation?
* Do proper lazy?
* Consider special data structures for 0-1 integers (assignments, predicate, compressed predicates)

* get_decision_level for predicate can be done better -> todo!()
* get_trail_position
* later on: lazy explanation for current decision level predicates, could try it out!

+ sometimes &IntegerPredicate, sometimes IntegerPredicate -> perhaps best to decide one or the other
* make assignment in assignments_integer, it checks the boughts, the calls the methods, but those methods anyway check the bounds.

* add propagator returns bool, should return Result?

* bumped priorities of other propagators, so that nogoods at at level 0? Actually if it is so slow then might as well give large priority? Problem since we do not delete!

* integration tests are amazing! But it took me a bit to understanding how to navigate the code. It just says test failed.

* fn debug_check_state for clausal_basic -> effectively deleted
* is_propagation_complete -> deleted!
* fn synchronise(&mut self, trail_size: usize) {

* integer_assignment exposes trail

* running int_lin_le -> wild variable selection
starts with x != 9, 8, 7, 6...(note that 10 is skipped), then goes to x != 1, and then decides x <= 9. Funny because 9 is not in the domain, it is effectively saying x = 0. What? Also branching on not_equals...


solver, line 1117 -> where are the other match cases?

assignments_integer.rs, line 926, was look at lower bound instead of upper bound
line 422, for the upper bound reason but not equals trail, used lower instead of upper bound

* need to cache reasons during computation in the analyser
* need to disallow duplicates during computation in the analyser
* semantic minimisation during reason extraction

* todo should double check this nogood!
//todo check if this makes sense

* temporary removed two cnf formulas from the tests

// mzn_search_unordered!(search_with_constants_in_search);
disabled maxsat tests

look at the Domain representation, and see what was the problem with some hacky thing, like at trail pos 0 we have some bound?

* What is the point of the OpaqueDomainEvent?

rename watch_list_cp, propagator_cp...remove 'cp'. Also watch_list within the nogood is called watch_list, could distinguish the two watch lists by name.

    fn peek_next_assumption_predicate(&self) -> Option<IntegerPredicate> { -> can be done in a single line!!


  making a decision returns a CSPSolverExecutionFlag -> this also has a timeout??

  removed virtual binary clauses -> we actually never got to use it.

  PropositionalConjunction -> Vec<IntegerPredicate>, there is a partialEq, do we want this? Or do we just make a new nogood vector? Instead of "PropositionalConjunction", we call it nogood?

  log nogoods?

  check process_learned_clause, and see if I am missing something

  predicates folder, look at mod, maybe we can remove, not sure

  StoredConflictInfo -> rename into conflict info?

  debug_propagator_reason -> not used anywhere?

  HasAssignments -> assignments_integer, can rename? Do we need this anymore?

LearningOptions? I removed it.

  in general need to go through code and fix things. E.g., debug_helper, propagator code.

  is a nogood actually a propositional conjunction?

  pub type PropagationStatusCP = Result<(), Inconsistency>;

  could have special functions for BooleanDomainId? Probably need to...?

  remove predicates from vsids that have very small values




  #[derive(Debug, Error, Copy, Clone)]
#[error("Attempt to transform non-integer predicate to integer predicate")]
pub struct IntegerPredicateConversionError;


Removed RPEngine and proof related things from the solve

removed VSIDS
removed solution guided search
phase saving


removed domain events boolean, can think about this


removed maxsat? There was an Instance in basic_types with a checker with functions that are allow dead code.

removed difference logic

Notify for BooleanDomain -> any, will notify for ==, and >=?

self.assignments_integer.num_trail_entries() -> this is used for the restart strategy, but this makes no sense.

check the impl blocks in the CSP solver, see if they still make sense

SAT options are not used anymore?

revisit encodings, not sure if it is done properly?

single_integer_encoding -> readd tests


disabled MaxSAT reading -> need to rethink how to do this, for example, if a literal is in the objective with both positive and negative polarity

Removed encoders!!

strenthen upper bound in linear search, do we need to go through the view to place an upper bound on the objective?


#[derive(Clone, Copy, Debug)]
/// A struct containing a literal, weight and (optionally) the bound which the literal represents
pub struct WeightedLiteral {
    pub variable: BooleanDomainId,
    pub weight: u64,
    /// The bound which the [`WeightedLiteral::literal`] represents (e.g. [x >= 5] would
    /// have bound Some(5))
    pub bound: Option<i32>,
}

todo: in the compile context, I replaced Literals with BooleanDomainId -> this assumes that the literals are all positive!

deleted dimacs parsing

post constraints...

constant_bool_true

Register returns a variable -> why have a return variable? I suppose we can remove the return value now.
search for "propagator variable", fix comment

linear_less_or_equal -> when registering, it does not take into account the return value! It still uses its own variable. Which is okay now but may change later. Same with linear_not_equal.

removed disjunctive scheduling example

branching.mod example ruined
predicates.mod ruined

//! Structures which represent certain [predicates](https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)). -> fix this.

Maybe BooleanVariable -> Literal? , struct Literal(IntegerPredicate)

initial_holes returns a vector? Could be an iterator, or a reference?

IntegerPredicate -> Predicate

When we add the blocking solution nogood, only consider predicates that are assigned as a result of a decision! Say max(a, b) = c, then if 'a' and 'b' are a result of a decision, then there is no need to add the value of 'c' to the nogood.

Assignments should never get into inconsistent state, make the check before getting inconsistent, this impact how we handle the EmptyDomain.

Trail does not properly handle the case when decisions are popped.


Where do we keep implementation of traits? For example, DomainId has IntegerVariable in its file, but the PredicateConstructor is in the predicate constructor file.

Do we want to have trivially true predicates? Hard without it I guess? For example AffineView, equality_predicate returns IntegerPredicate...

What do we watch for literals? How to implement it correctly? Does it make sense to implement Scaled literal for instance.... 

feature/revamp_skeleton4_removing_literals

Observation: clauses of literals that were propagated at a higher decision level do not get bumped! Nor their LBDs updated! Seems counter-intuitive to only look at current decision level.

predicate!(domain_id == 1) -> ok, but not 'predicate!(self.new_variable(0, 1) == 1)'

preprocessing could make use of the True and False predicates.

preprocessing -> how to remove opposite predicates?


VSIDS is a bit awkward. Bumping [x >= 3] and then [x >= 2] and then [x >= 1], which could happen due to lifting, may result in those predicates having lower scores compared to not doing lifting and simply bumping [x >= 3] three times. I guess we should bump the non-lifted values, and then lifted values? Or it might make sense to bump variables, and then bump values of the variable, so when we ask for branching, we first select variable and then value.

Tests for VSIDS -> restore

Phase saving not replicated

fix citations

implement SGS update

need on_predicate for branchers!

Assumptions -> can this be simplified in some way, say we first assign the predicates on the trail unless conflicting values, and then call the search? We would lose info on at which decision level we propagated things but that is not important anyway! This would simplify some parts of the solver, while make other parts a bit more complicated, could be worth it!

let's study how often variables appear in the proof, and how successful are our strategies at finding those variables. The hypothesis is that strategies that are good at that are good at finding unsat solutions. Problem: there may be many different proofs.

Propagators provide info for autonomous search. Possibly they also take into account importance of variables as evidenced by explanations.

Update propagators with nogood information.

Runtime data-driven priority queue.