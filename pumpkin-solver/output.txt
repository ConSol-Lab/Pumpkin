#![feature(prelude_import)]
#![cfg(test)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod helpers {
    //! Crate to run integration tests for the solver.
    #![allow(dead_code)]
    pub(crate) mod flatzinc {
        use std::collections::BTreeMap;
        use std::collections::BTreeSet;
        use std::fmt::Display;
        use std::str::FromStr;
        use regex::Regex;
        #[allow(variant_size_differences)]
        pub(crate) enum Value {
            Int(i32),
            Bool(bool),
            IntArray(Vec<i32>),
        }
        #[automatically_derived]
        #[allow(variant_size_differences)]
        impl ::core::fmt::Debug for Value {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Value::Int(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Int",
                            &__self_0,
                        )
                    }
                    Value::Bool(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Bool",
                            &__self_0,
                        )
                    }
                    Value::IntArray(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "IntArray",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(variant_size_differences)]
        impl ::core::marker::StructuralPartialEq for Value {}
        #[automatically_derived]
        #[allow(variant_size_differences)]
        impl ::core::cmp::PartialEq for Value {
            #[inline]
            fn eq(&self, other: &Value) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (Value::Int(__self_0), Value::Int(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (Value::Bool(__self_0), Value::Bool(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (Value::IntArray(__self_0), Value::IntArray(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        #[allow(variant_size_differences)]
        impl ::core::cmp::Eq for Value {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<i32>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<Vec<i32>>;
            }
        }
        #[automatically_derived]
        #[allow(variant_size_differences)]
        impl ::core::cmp::PartialOrd for Value {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Value,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match (self, other) {
                    (Value::Int(__self_0), Value::Int(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (Value::Bool(__self_0), Value::Bool(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (Value::IntArray(__self_0), Value::IntArray(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    _ => {
                        ::core::cmp::PartialOrd::partial_cmp(
                            &__self_discr,
                            &__arg1_discr,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(variant_size_differences)]
        impl ::core::cmp::Ord for Value {
            #[inline]
            fn cmp(&self, other: &Value) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (Value::Int(__self_0), Value::Int(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Value::Bool(__self_0), Value::Bool(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Value::IntArray(__self_0), Value::IntArray(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        impl FromStr for Value {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                s.parse::<i32>()
                    .map(Value::Int)
                    .or_else(|_| {
                        s.parse::<bool>()
                            .map(Value::Bool)
                            .or_else(|_| create_array_from_string(s))
                    })
                    .map_err(|e| e.to_string())
            }
        }
        struct IntArrayError;
        impl Display for IntArrayError {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_str("Could not parse int array")
            }
        }
        fn create_array_from_string(s: &str) -> Result<Value, IntArrayError> {
            let captures = Regex::new(
                    r"array1d\([0-9]+\.\.[0-9]+,\s*\[(\d+(?:,\s\d+)*\d*)\]\)",
                )
                .unwrap()
                .captures_iter(s)
                .next();
            if let Some(captures) = captures {
                Ok(
                    Value::IntArray(
                        captures
                            .get(1)
                            .unwrap()
                            .as_str()
                            .split(", ")
                            .map(|integer| integer.parse::<i32>().unwrap())
                            .collect::<Vec<_>>(),
                    ),
                )
            } else {
                Err(IntArrayError)
            }
        }
        pub(crate) struct Solutions<const ORDERED: bool> {
            pub(crate) assignments: Vec<BTreeMap<String, Value>>,
        }
        #[automatically_derived]
        impl<const ORDERED: bool> ::core::fmt::Debug for Solutions<ORDERED> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Solutions",
                    "assignments",
                    &&self.assignments,
                )
            }
        }
        impl<const ORDERED: bool> PartialEq for Solutions<ORDERED> {
            fn eq(&self, other: &Self) -> bool {
                if ORDERED {
                    self.assignments == other.assignments
                } else {
                    self.assignments.iter().collect::<BTreeSet<_>>()
                        == other.assignments.iter().collect::<BTreeSet<_>>()
                }
            }
        }
        impl<const ORDERED: bool> FromStr for Solutions<ORDERED> {
            type Err = String;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                let s = s.trim();
                if !s.ends_with("==========") {
                    return Err("solutions should end with '=========='".into());
                }
                let assignments = s
                    .split("----------")
                    .map(parse_solution)
                    .collect::<Result<_, _>>()?;
                Ok(Solutions { assignments })
            }
        }
        fn parse_solution(solution: &str) -> Result<BTreeMap<String, Value>, String> {
            let solution = solution.trim().trim_end_matches("==========");
            solution
                .lines()
                .map(|line| line.trim())
                .filter(|line| !line.is_empty() && !line.starts_with('%'))
                .map(parse_solution_line)
                .collect()
        }
        fn parse_solution_line(line: &str) -> Result<(String, Value), String> {
            let mut components = line.split(" = ");
            let variable = components
                .next()
                .ok_or_else(|| ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("Invalid solution line \'{0}\'", line),
                    );
                    res
                }))?
                .to_owned();
            let value = components
                .next()
                .ok_or_else(|| ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("Invalid solution line \'{0}\'", line),
                    );
                    res
                }))?
                .trim_end_matches(';')
                .parse::<Value>()
                .map_err(|_| ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("Failed to parse value from \'{0}\'", line),
                    );
                    res
                }))?;
            Ok((variable, value))
        }
    }
    use std::fs::File;
    use std::path::Path;
    use std::path::PathBuf;
    use std::process::Command;
    use std::process::Output;
    use std::process::Stdio;
    use std::time::Duration;
    use flatzinc::Solutions;
    use wait_timeout::ChildExt;
    pub(crate) struct Files {
        pub(crate) instance_file: PathBuf,
        pub(crate) proof_file: PathBuf,
        pub(crate) log_file: PathBuf,
        pub(crate) err_file: PathBuf,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Files {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Files",
                "instance_file",
                &self.instance_file,
                "proof_file",
                &self.proof_file,
                "log_file",
                &self.log_file,
                "err_file",
                &&self.err_file,
            )
        }
    }
    impl Files {
        pub(crate) fn cleanup(self) -> std::io::Result<()> {
            std::fs::remove_file(self.log_file)?;
            std::fs::remove_file(self.err_file)?;
            if self.proof_file.is_file() {
                std::fs::remove_file(self.proof_file)?;
            }
            Ok(())
        }
    }
    pub(crate) fn run_solver(
        instance_path: impl AsRef<Path>,
        with_proof: bool,
    ) -> Files {
        run_solver_with_options(instance_path, with_proof, std::iter::empty(), None)
    }
    pub(crate) fn run_solver_with_options<'a>(
        instance_path: impl AsRef<Path>,
        with_proof: bool,
        args: impl IntoIterator<Item = &'a str>,
        prefix: Option<&str>,
    ) -> Files {
        let args = args.into_iter().collect::<Vec<_>>();
        const TEST_TIMEOUT: Duration = Duration::from_secs(60);
        let instance_path = instance_path.as_ref();
        let solver = PathBuf::from("/home/imko/Pumpkin/target/debug/pumpkin-solver");
        let add_extension = |extension: &str| -> PathBuf {
            if let Some(prefix) = prefix {
                instance_path
                    .with_extension(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("{0}.{1}", prefix, extension),
                            );
                            res
                        }),
                    )
            } else {
                instance_path.with_extension(extension)
            }
        };
        let log_file_path = add_extension("log");
        let err_file_path = add_extension("err");
        let proof_file_path = add_extension("proof");
        let mut command = Command::new(solver);
        if with_proof {
            let _ = command.arg("--proof-path").arg(&proof_file_path);
        }
        for arg in args {
            let _ = command.arg(arg);
        }
        let mut child = command
            .arg(instance_path)
            .stdout(
                File::create(&log_file_path)
                    .expect("Failed to create log file for {instance_name}."),
            )
            .stderr(
                File::create(&err_file_path)
                    .expect("Failed to create error file for {instance_name}."),
            )
            .stdin(Stdio::null())
            .spawn()
            .expect("Failed to run solver.");
        match child.wait_timeout(TEST_TIMEOUT) {
            Ok(None) => {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "solver took more than {0} seconds",
                        TEST_TIMEOUT.as_secs(),
                    ),
                );
            }
            Ok(Some(status)) if status.success() => {}
            Ok(Some(e)) => {
                ::core::panicking::panic_fmt(
                    format_args!("error solving instance {0}", e),
                );
            }
            Err(e) => {
                ::core::panicking::panic_fmt(
                    format_args!("error starting solver: {0}", e),
                );
            }
        }
        Files {
            instance_file: instance_path.to_path_buf(),
            log_file: log_file_path,
            proof_file: proof_file_path,
            err_file: err_file_path,
        }
    }
    pub(crate) fn get_executable(path: impl AsRef<Path>) -> PathBuf {
        if false {
            path.as_ref().with_extension("exe")
        } else {
            path.as_ref().to_path_buf()
        }
    }
    pub(crate) enum CheckerOutput {
        Panic,
        Acceptable,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for CheckerOutput {}
    #[automatically_derived]
    impl ::core::clone::Clone for CheckerOutput {
        #[inline]
        fn clone(&self) -> CheckerOutput {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CheckerOutput {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    CheckerOutput::Panic => "Panic",
                    CheckerOutput::Acceptable => "Acceptable",
                },
            )
        }
    }
    pub(crate) trait Checker {
        fn executable_name(&self) -> &'static str;
        fn prepare_command(&self, cmd: &mut Command, files: &Files);
        fn parse_checker_output(&self, output: &Output) -> CheckerOutput;
        fn after_checking_action(&self, files: Files, _output: &Output) {
            files.cleanup().unwrap()
        }
    }
    pub(crate) fn run_solution_checker(files: Files, checker: impl Checker) {
        let checker_exe = get_executable(
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}/{1}",
                        "/home/imko/Pumpkin/target/debug/build/pumpkin-solver-c1450be3951aceec/out",
                        checker.executable_name(),
                    ),
                );
                res
            }),
        );
        let mut command = Command::new(checker_exe);
        let _ = command
            .stdout(Stdio::piped())
            .stdin(Stdio::null())
            .stderr(Stdio::piped());
        checker.prepare_command(&mut command, &files);
        let output = command
            .output()
            .unwrap_or_else(|_| {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "Failed to run solution checker: {0}",
                            checker.executable_name(),
                        ),
                    );
                }
            });
        match checker.parse_checker_output(&output) {
            CheckerOutput::Panic => {
                {
                    ::std::io::_print(
                        format_args!(
                            "{0}\n",
                            std::str::from_utf8(&output.stdout).unwrap(),
                        ),
                    );
                };
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "Failed to verify solution file. Checker exited with code {0}",
                            output.status,
                        ),
                    );
                };
            }
            CheckerOutput::Acceptable => checker.after_checking_action(files, &output),
        }
    }
    pub(crate) fn verify_proof(
        files: Files,
        checker_output: &Output,
    ) -> std::io::Result<()> {
        if checker_output.status.code().unwrap() == 0 {
            return Ok(());
        }
        let drat_trim = get_executable(
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}/drat-trim",
                        "/home/imko/Pumpkin/target/debug/build/pumpkin-solver-c1450be3951aceec/out",
                    ),
                );
                res
            }),
        );
        let output = Command::new(drat_trim)
            .stdout(Stdio::piped())
            .arg(&files.instance_file)
            .arg(&files.proof_file)
            .output()
            .expect("Failed to run drat-trim");
        if !output.status.success() {
            {
                ::std::io::_print(
                    format_args!("{0}\n", std::str::from_utf8(&output.stdout).unwrap()),
                );
            };
            {
                ::core::panicking::panic_fmt(
                    format_args!("drat-trim reported an error"),
                );
            };
        }
        files.cleanup()
    }
    pub(crate) fn run_mzn_test<const ORDERED: bool>(
        instance_name: &str,
        folder_name: &str,
    ) {
        run_mzn_test_with_options::<
            ORDERED,
        >(instance_name, folder_name, ::alloc::vec::Vec::new(), "")
    }
    pub(crate) fn check_statistic_equality(
        instance_name: &str,
        folder_name: &str,
        mut options_first: Vec<&str>,
        mut options_second: Vec<&str>,
        prefix_first: &str,
        prefix_second: &str,
    ) {
        let instance_path = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(
                format_args!(
                    "{0}/tests/{1}/{2}.fzn",
                    "/home/imko/Pumpkin/pumpkin-solver",
                    folder_name,
                    instance_name,
                ),
            );
            res
        });
        options_first.push("-sa");
        options_second.push("-sa");
        let files_first = run_solver_with_options(
            instance_path.clone(),
            false,
            options_first,
            Some(prefix_first),
        );
        let files_second = run_solver_with_options(
            instance_path,
            false,
            options_second,
            Some(prefix_second),
        );
        let output_first = std::fs::read_to_string(files_first.log_file)
            .expect("Failed to read solver output");
        let output_second = std::fs::read_to_string(files_second.log_file)
            .expect("Failed to read solver output");
        let filtered_output_first = output_first
            .lines()
            .filter(|line| {
                line.starts_with("%%%mzn-stat") && !line.contains("imeSpentInSolver")
            })
            .collect::<Vec<&str>>();
        let filtered_output_second = output_second
            .lines()
            .filter(|line| {
                line.starts_with("%%%mzn-stat") && !line.contains("imeSpentInSolver")
            })
            .collect::<Vec<&str>>();
        match (&filtered_output_first, &filtered_output_second) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::Some(
                            format_args!(
                                "Lines first differ at:\n{0:?}",
                                {
                                    match (
                                        &filtered_output_first.len(),
                                        &filtered_output_second.len(),
                                    ) {
                                        (left_val, right_val) => {
                                            if !(*left_val == *right_val) {
                                                let kind = ::core::panicking::AssertKind::Eq;
                                                ::core::panicking::assert_failed(
                                                    kind,
                                                    &*left_val,
                                                    &*right_val,
                                                    ::core::option::Option::Some(
                                                        format_args!("The output length was not the same"),
                                                    ),
                                                );
                                            }
                                        }
                                    };
                                    filtered_output_first
                                        .iter()
                                        .zip(filtered_output_second.iter())
                                        .find(|(a, b)| a != b)
                                        .unwrap()
                                },
                            ),
                        ),
                    );
                }
            }
        }
    }
    pub(crate) fn run_mzn_test_with_options<const ORDERED: bool>(
        instance_name: &str,
        folder_name: &str,
        mut options: Vec<&str>,
        prefix: &str,
    ) {
        let instance_path = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(
                format_args!(
                    "{0}/tests/{1}/{2}.fzn",
                    "/home/imko/Pumpkin/pumpkin-solver",
                    folder_name,
                    instance_name,
                ),
            );
            res
        });
        let snapshot_path = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(
                format_args!(
                    "{0}/tests/{1}/{2}.expected",
                    "/home/imko/Pumpkin/pumpkin-solver",
                    folder_name,
                    instance_name,
                ),
            );
            res
        });
        options.push("-a");
        let files = run_solver_with_options(instance_path, false, options, Some(prefix));
        let output = std::fs::read_to_string(files.log_file)
            .expect("Failed to read solver output");
        let expected_file = std::fs::read_to_string(snapshot_path)
            .expect("Failed to read expected solution file.");
        let actual_solutions = output
            .parse::<Solutions<ORDERED>>()
            .expect("Valid solution");
        let expected_solutions = expected_file
            .parse::<Solutions<ORDERED>>()
            .expect("Valid solution");
        match (&actual_solutions, &expected_solutions) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::Some(
                            format_args!(
                                "Did not find the elements {0:?} in the expected solution and the expected solution contained {1:?} while the actual solution did not.",
                                actual_solutions
                                    .assignments
                                    .iter()
                                    .filter(|solution| {
                                        !expected_solutions.assignments.contains(solution)
                                    })
                                    .collect::<Vec<_>>(),
                                expected_solutions
                                    .assignments
                                    .iter()
                                    .filter(|solution| {
                                        !actual_solutions.assignments.contains(solution)
                                    })
                                    .collect::<Vec<_>>(),
                            ),
                        ),
                    );
                }
            }
        };
    }
}
use helpers::check_statistic_equality;
use helpers::run_mzn_test_with_options;
use test_macros::cumulative;
use test_macros::cumulative_synchronised;
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_lin_ne"]
pub const int_lin_ne: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_lin_ne"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 285usize,
        start_col: 11usize,
        end_line: 285usize,
        end_col: 21usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(int_lin_ne()),
    ),
};
fn int_lin_ne() {
    run_mzn_test_with_options::<
        false,
    >("int_lin_ne", "mzn_constraints", ::alloc::vec::Vec::new(), "int_lin_ne");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_lin_ne_reif"]
pub const int_lin_ne_reif: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_lin_ne_reif"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 286usize,
        start_col: 11usize,
        end_line: 286usize,
        end_col: 26usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(int_lin_ne_reif()),
    ),
};
fn int_lin_ne_reif() {
    run_mzn_test_with_options::<
        false,
    >("int_lin_ne_reif", "mzn_constraints", ::alloc::vec::Vec::new(), "int_lin_ne_reif");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_lin_le"]
pub const int_lin_le: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_lin_le"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 287usize,
        start_col: 11usize,
        end_line: 287usize,
        end_col: 21usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(int_lin_le()),
    ),
};
fn int_lin_le() {
    run_mzn_test_with_options::<
        false,
    >("int_lin_le", "mzn_constraints", ::alloc::vec::Vec::new(), "int_lin_le");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_lin_le_reif"]
pub const int_lin_le_reif: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_lin_le_reif"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 288usize,
        start_col: 11usize,
        end_line: 288usize,
        end_col: 26usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(int_lin_le_reif()),
    ),
};
fn int_lin_le_reif() {
    run_mzn_test_with_options::<
        false,
    >("int_lin_le_reif", "mzn_constraints", ::alloc::vec::Vec::new(), "int_lin_le_reif");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_lin_eq"]
pub const int_lin_eq: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_lin_eq"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 289usize,
        start_col: 11usize,
        end_line: 289usize,
        end_col: 21usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(int_lin_eq()),
    ),
};
fn int_lin_eq() {
    run_mzn_test_with_options::<
        false,
    >("int_lin_eq", "mzn_constraints", ::alloc::vec::Vec::new(), "int_lin_eq");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_lin_eq_reif"]
pub const int_lin_eq_reif: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_lin_eq_reif"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 290usize,
        start_col: 11usize,
        end_line: 290usize,
        end_col: 26usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(int_lin_eq_reif()),
    ),
};
fn int_lin_eq_reif() {
    run_mzn_test_with_options::<
        false,
    >("int_lin_eq_reif", "mzn_constraints", ::alloc::vec::Vec::new(), "int_lin_eq_reif");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_eq"]
pub const int_eq: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_eq"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 292usize,
        start_col: 11usize,
        end_line: 292usize,
        end_col: 17usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_eq())),
};
fn int_eq() {
    run_mzn_test_with_options::<
        false,
    >("int_eq", "mzn_constraints", ::alloc::vec::Vec::new(), "int_eq");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_eq_reif"]
pub const int_eq_reif: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_eq_reif"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 293usize,
        start_col: 11usize,
        end_line: 293usize,
        end_col: 22usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(int_eq_reif()),
    ),
};
fn int_eq_reif() {
    run_mzn_test_with_options::<
        false,
    >("int_eq_reif", "mzn_constraints", ::alloc::vec::Vec::new(), "int_eq_reif");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_ne"]
pub const int_ne: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_ne"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 294usize,
        start_col: 11usize,
        end_line: 294usize,
        end_col: 17usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_ne())),
};
fn int_ne() {
    run_mzn_test_with_options::<
        false,
    >("int_ne", "mzn_constraints", ::alloc::vec::Vec::new(), "int_ne");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_ne_reif"]
pub const int_ne_reif: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_ne_reif"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 295usize,
        start_col: 11usize,
        end_line: 295usize,
        end_col: 22usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(int_ne_reif()),
    ),
};
fn int_ne_reif() {
    run_mzn_test_with_options::<
        false,
    >("int_ne_reif", "mzn_constraints", ::alloc::vec::Vec::new(), "int_ne_reif");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_le"]
pub const int_le: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_le"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 296usize,
        start_col: 11usize,
        end_line: 296usize,
        end_col: 17usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_le())),
};
fn int_le() {
    run_mzn_test_with_options::<
        false,
    >("int_le", "mzn_constraints", ::alloc::vec::Vec::new(), "int_le");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_le_reif"]
pub const int_le_reif: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_le_reif"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 297usize,
        start_col: 11usize,
        end_line: 297usize,
        end_col: 22usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(int_le_reif()),
    ),
};
fn int_le_reif() {
    run_mzn_test_with_options::<
        false,
    >("int_le_reif", "mzn_constraints", ::alloc::vec::Vec::new(), "int_le_reif");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_lt"]
pub const int_lt: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_lt"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 298usize,
        start_col: 11usize,
        end_line: 298usize,
        end_col: 17usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_lt())),
};
fn int_lt() {
    run_mzn_test_with_options::<
        false,
    >("int_lt", "mzn_constraints", ::alloc::vec::Vec::new(), "int_lt");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_lt_reif"]
pub const int_lt_reif: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_lt_reif"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 299usize,
        start_col: 11usize,
        end_line: 299usize,
        end_col: 22usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(int_lt_reif()),
    ),
};
fn int_lt_reif() {
    run_mzn_test_with_options::<
        false,
    >("int_lt_reif", "mzn_constraints", ::alloc::vec::Vec::new(), "int_lt_reif");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_times"]
pub const int_times: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_times"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 301usize,
        start_col: 11usize,
        end_line: 301usize,
        end_col: 20usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_times())),
};
fn int_times() {
    run_mzn_test_with_options::<
        false,
    >("int_times", "mzn_constraints", ::alloc::vec::Vec::new(), "int_times");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_plus"]
pub const int_plus: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_plus"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 302usize,
        start_col: 11usize,
        end_line: 302usize,
        end_col: 19usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_plus())),
};
fn int_plus() {
    run_mzn_test_with_options::<
        false,
    >("int_plus", "mzn_constraints", ::alloc::vec::Vec::new(), "int_plus");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_abs"]
pub const int_abs: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_abs"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 303usize,
        start_col: 11usize,
        end_line: 303usize,
        end_col: 18usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_abs())),
};
fn int_abs() {
    run_mzn_test_with_options::<
        false,
    >("int_abs", "mzn_constraints", ::alloc::vec::Vec::new(), "int_abs");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_div"]
pub const int_div: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_div"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 304usize,
        start_col: 11usize,
        end_line: 304usize,
        end_col: 18usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_div())),
};
fn int_div() {
    run_mzn_test_with_options::<
        false,
    >("int_div", "mzn_constraints", ::alloc::vec::Vec::new(), "int_div");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_mod"]
pub const int_mod: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_mod"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 305usize,
        start_col: 11usize,
        end_line: 305usize,
        end_col: 18usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_mod())),
};
fn int_mod() {
    run_mzn_test_with_options::<
        false,
    >("int_mod", "mzn_constraints", ::alloc::vec::Vec::new(), "int_mod");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "array_int_maximum"]
pub const array_int_maximum: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("array_int_maximum"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 307usize,
        start_col: 11usize,
        end_line: 307usize,
        end_col: 28usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(array_int_maximum()),
    ),
};
fn array_int_maximum() {
    run_mzn_test_with_options::<
        false,
    >(
        "array_int_maximum",
        "mzn_constraints",
        ::alloc::vec::Vec::new(),
        "array_int_maximum",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "array_int_minimum"]
pub const array_int_minimum: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("array_int_minimum"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 308usize,
        start_col: 11usize,
        end_line: 308usize,
        end_col: 28usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(array_int_minimum()),
    ),
};
fn array_int_minimum() {
    run_mzn_test_with_options::<
        false,
    >(
        "array_int_minimum",
        "mzn_constraints",
        ::alloc::vec::Vec::new(),
        "array_int_minimum",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_min"]
pub const int_min: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_min"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 309usize,
        start_col: 11usize,
        end_line: 309usize,
        end_col: 18usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_min())),
};
fn int_min() {
    run_mzn_test_with_options::<
        false,
    >("int_min", "mzn_constraints", ::alloc::vec::Vec::new(), "int_min");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "int_max"]
pub const int_max: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("int_max"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 310usize,
        start_col: 11usize,
        end_line: 310usize,
        end_col: 18usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(int_max())),
};
fn int_max() {
    run_mzn_test_with_options::<
        false,
    >("int_max", "mzn_constraints", ::alloc::vec::Vec::new(), "int_max");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "set_in"]
pub const set_in: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("set_in"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 312usize,
        start_col: 11usize,
        end_line: 312usize,
        end_col: 17usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(set_in())),
};
fn set_in() {
    run_mzn_test_with_options::<
        false,
    >("set_in", "mzn_constraints", ::alloc::vec::Vec::new(), "set_in");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "set_in_reif_interval"]
pub const set_in_reif_interval: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("set_in_reif_interval"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 313usize,
        start_col: 11usize,
        end_line: 313usize,
        end_col: 31usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(set_in_reif_interval()),
    ),
};
fn set_in_reif_interval() {
    run_mzn_test_with_options::<
        false,
    >(
        "set_in_reif_interval",
        "mzn_constraints",
        ::alloc::vec::Vec::new(),
        "set_in_reif_interval",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "set_in_reif_sparse"]
pub const set_in_reif_sparse: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("set_in_reif_sparse"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 314usize,
        start_col: 11usize,
        end_line: 314usize,
        end_col: 29usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(set_in_reif_sparse()),
    ),
};
fn set_in_reif_sparse() {
    run_mzn_test_with_options::<
        false,
    >(
        "set_in_reif_sparse",
        "mzn_constraints",
        ::alloc::vec::Vec::new(),
        "set_in_reif_sparse",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "bool_xor_reif"]
pub const bool_xor_reif: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("bool_xor_reif"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 316usize,
        start_col: 11usize,
        end_line: 316usize,
        end_col: 24usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(bool_xor_reif()),
    ),
};
fn bool_xor_reif() {
    run_mzn_test_with_options::<
        false,
    >("bool_xor_reif", "mzn_constraints", ::alloc::vec::Vec::new(), "bool_xor_reif");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "bool_xor"]
pub const bool_xor: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("bool_xor"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 317usize,
        start_col: 11usize,
        end_line: 317usize,
        end_col: 19usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(bool_xor())),
};
fn bool_xor() {
    run_mzn_test_with_options::<
        false,
    >("bool_xor", "mzn_constraints", ::alloc::vec::Vec::new(), "bool_xor");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "bool_not"]
pub const bool_not: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("bool_not"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 318usize,
        start_col: 11usize,
        end_line: 318usize,
        end_col: 19usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(#[coverage(off)] || test::assert_test_result(bool_not())),
};
fn bool_not() {
    run_mzn_test_with_options::<
        false,
    >("bool_not", "mzn_constraints", ::alloc::vec::Vec::new(), "bool_not");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "bool_lin_eq"]
pub const bool_lin_eq: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("bool_lin_eq"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 320usize,
        start_col: 11usize,
        end_line: 320usize,
        end_col: 22usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(bool_lin_eq()),
    ),
};
fn bool_lin_eq() {
    run_mzn_test_with_options::<
        false,
    >("bool_lin_eq", "mzn_constraints", ::alloc::vec::Vec::new(), "bool_lin_eq");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "bool_lin_le"]
pub const bool_lin_le: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("bool_lin_le"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 321usize,
        start_col: 11usize,
        end_line: 321usize,
        end_col: 22usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(bool_lin_le()),
    ),
};
fn bool_lin_le() {
    run_mzn_test_with_options::<
        false,
    >("bool_lin_le", "mzn_constraints", ::alloc::vec::Vec::new(), "bool_lin_le");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "bool_clause"]
pub const bool_clause: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("bool_clause"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 322usize,
        start_col: 11usize,
        end_line: 322usize,
        end_col: 22usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(bool_clause()),
    ),
};
fn bool_clause() {
    run_mzn_test_with_options::<
        false,
    >("bool_clause", "mzn_constraints", ::alloc::vec::Vec::new(), "bool_clause");
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_naive"]
pub const cumulative_time_table_per_point_naive: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_per_point_naive"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 197usize,
        start_col: 17usize,
        end_line: 197usize,
        end_col: 53usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_per_point_naive()),
    ),
};
fn cumulative_time_table_per_point_naive() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "naive",
            ]),
        ),
        "cumulative_time_table_per_point_naive",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_big_step"]
pub const cumulative_time_table_per_point_big_step: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_per_point_big_step"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 204usize,
        start_col: 17usize,
        end_line: 204usize,
        end_col: 56usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_per_point_big_step()),
    ),
};
fn cumulative_time_table_per_point_big_step() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "big-step",
            ]),
        ),
        "cumulative_time_table_per_point_big_step",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_pointwise"]
pub const cumulative_time_table_per_point_pointwise: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_per_point_pointwise"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 211usize,
        start_col: 17usize,
        end_line: 211usize,
        end_col: 57usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_per_point_pointwise()),
    ),
};
fn cumulative_time_table_per_point_pointwise() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "pointwise",
            ]),
        ),
        "cumulative_time_table_per_point_pointwise",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_naive_sequence"]
pub const cumulative_time_table_per_point_naive_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_per_point_naive_sequence"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 219usize,
        start_col: 17usize,
        end_line: 219usize,
        end_col: 62usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_per_point_naive_sequence()),
    ),
};
fn cumulative_time_table_per_point_naive_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_naive_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_big_step_sequence"]
pub const cumulative_time_table_per_point_big_step_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_per_point_big_step_sequence"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 226usize,
        start_col: 17usize,
        end_line: 226usize,
        end_col: 65usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_per_point_big_step_sequence()),
    ),
};
fn cumulative_time_table_per_point_big_step_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_big_step_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_pointwise_sequence"]
pub const cumulative_time_table_per_point_pointwise_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_per_point_pointwise_sequence"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 233usize,
        start_col: 17usize,
        end_line: 233usize,
        end_col: 66usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_per_point_pointwise_sequence()),
    ),
};
fn cumulative_time_table_per_point_pointwise_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_pointwise_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_naive_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_naive_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_naive_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 241usize,
        start_col: 17usize,
        end_line: 241usize,
        end_col: 87usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_naive_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_naive_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_naive_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_big_step_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_big_step_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_big_step_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 248usize,
        start_col: 17usize,
        end_line: 248usize,
        end_col: 90usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_big_step_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_big_step_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_big_step_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_pointwise_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_pointwise_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_pointwise_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 255usize,
        start_col: 17usize,
        end_line: 255usize,
        end_col: 91usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_pointwise_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_pointwise_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_pointwise_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_naive_incremental_backtracking"]
pub const cumulative_time_table_per_point_naive_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_naive_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 263usize,
        start_col: 17usize,
        end_line: 263usize,
        end_col: 78usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_naive_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_naive_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_per_point_naive_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_big_step_incremental_backtracking"]
pub const cumulative_time_table_per_point_big_step_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_big_step_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 270usize,
        start_col: 17usize,
        end_line: 270usize,
        end_col: 81usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_big_step_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_big_step_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_per_point_big_step_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_pointwise_incremental_backtracking"]
pub const cumulative_time_table_per_point_pointwise_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_pointwise_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 277usize,
        start_col: 17usize,
        end_line: 277usize,
        end_col: 82usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_pointwise_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_pointwise_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_per_point_pointwise_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_naive"]
pub const cumulative_time_table_per_point_incremental_naive: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_per_point_incremental_naive"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 197usize,
        start_col: 17usize,
        end_line: 197usize,
        end_col: 53usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_per_point_incremental_naive()),
    ),
};
fn cumulative_time_table_per_point_incremental_naive() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "naive",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_naive",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_big_step"]
pub const cumulative_time_table_per_point_incremental_big_step: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_big_step",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 204usize,
        start_col: 17usize,
        end_line: 204usize,
        end_col: 56usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_big_step(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_big_step() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "big-step",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_big_step",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_pointwise"]
pub const cumulative_time_table_per_point_incremental_pointwise: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_pointwise",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 211usize,
        start_col: 17usize,
        end_line: 211usize,
        end_col: 57usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_pointwise(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_pointwise() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "pointwise",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_pointwise",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_naive_sequence"]
pub const cumulative_time_table_per_point_incremental_naive_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_naive_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 219usize,
        start_col: 17usize,
        end_line: 219usize,
        end_col: 62usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_naive_sequence(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_naive_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_naive_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_big_step_sequence"]
pub const cumulative_time_table_per_point_incremental_big_step_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_big_step_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 226usize,
        start_col: 17usize,
        end_line: 226usize,
        end_col: 65usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_big_step_sequence(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_big_step_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_big_step_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_pointwise_sequence"]
pub const cumulative_time_table_per_point_incremental_pointwise_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_pointwise_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 233usize,
        start_col: 17usize,
        end_line: 233usize,
        end_col: 66usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_pointwise_sequence(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_pointwise_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_pointwise_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_naive_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_naive_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_naive_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 241usize,
        start_col: 17usize,
        end_line: 241usize,
        end_col: 87usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_naive_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_naive_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_naive_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_big_step_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_big_step_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_big_step_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 248usize,
        start_col: 17usize,
        end_line: 248usize,
        end_col: 90usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_big_step_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_big_step_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_big_step_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_pointwise_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_pointwise_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_pointwise_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 255usize,
        start_col: 17usize,
        end_line: 255usize,
        end_col: 91usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_pointwise_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_pointwise_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_pointwise_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_naive_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_naive_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_naive_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 263usize,
        start_col: 17usize,
        end_line: 263usize,
        end_col: 78usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_naive_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_naive_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_naive_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_big_step_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_big_step_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_big_step_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 270usize,
        start_col: 17usize,
        end_line: 270usize,
        end_col: 81usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_big_step_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_big_step_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_big_step_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_pointwise_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_pointwise_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_pointwise_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 277usize,
        start_col: 17usize,
        end_line: 277usize,
        end_col: 82usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_pointwise_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_pointwise_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_pointwise_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_naive"]
pub const cumulative_time_table_per_point_incremental_synchronised_naive: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_naive",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 197usize,
        start_col: 17usize,
        end_line: 197usize,
        end_col: 53usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_naive(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_naive() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "naive",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_naive",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_big_step"]
pub const cumulative_time_table_per_point_incremental_synchronised_big_step: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_big_step",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 204usize,
        start_col: 17usize,
        end_line: 204usize,
        end_col: 56usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_big_step(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_big_step() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "big-step",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_big_step",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_pointwise"]
pub const cumulative_time_table_per_point_incremental_synchronised_pointwise: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_pointwise",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 211usize,
        start_col: 17usize,
        end_line: 211usize,
        end_col: 57usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_pointwise(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_pointwise() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "pointwise",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_pointwise",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_naive_sequence"]
pub const cumulative_time_table_per_point_incremental_synchronised_naive_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_naive_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 219usize,
        start_col: 17usize,
        end_line: 219usize,
        end_col: 62usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_naive_sequence(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_naive_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_naive_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_big_step_sequence"]
pub const cumulative_time_table_per_point_incremental_synchronised_big_step_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_big_step_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 226usize,
        start_col: 17usize,
        end_line: 226usize,
        end_col: 65usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_big_step_sequence(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_big_step_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_big_step_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence"]
pub const cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 233usize,
        start_col: 17usize,
        end_line: 233usize,
        end_col: 66usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 241usize,
        start_col: 17usize,
        end_line: 241usize,
        end_col: 87usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 248usize,
        start_col: 17usize,
        end_line: 248usize,
        end_col: 90usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 255usize,
        start_col: 17usize,
        end_line: 255usize,
        end_col: 91usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_naive_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_synchronised_naive_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_naive_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 263usize,
        start_col: 17usize,
        end_line: 263usize,
        end_col: 78usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_naive_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_naive_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_naive_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 270usize,
        start_col: 17usize,
        end_line: 270usize,
        end_col: 81usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking"]
pub const cumulative_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 277usize,
        start_col: 17usize,
        end_line: 277usize,
        end_col: 82usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_naive"]
pub const cumulative_time_table_over_interval_naive: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_over_interval_naive"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 197usize,
        start_col: 17usize,
        end_line: 197usize,
        end_col: 53usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_over_interval_naive()),
    ),
};
fn cumulative_time_table_over_interval_naive() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "naive",
            ]),
        ),
        "cumulative_time_table_over_interval_naive",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_big_step"]
pub const cumulative_time_table_over_interval_big_step: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_over_interval_big_step"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 204usize,
        start_col: 17usize,
        end_line: 204usize,
        end_col: 56usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_over_interval_big_step()),
    ),
};
fn cumulative_time_table_over_interval_big_step() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "big-step",
            ]),
        ),
        "cumulative_time_table_over_interval_big_step",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_pointwise"]
pub const cumulative_time_table_over_interval_pointwise: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_over_interval_pointwise"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 211usize,
        start_col: 17usize,
        end_line: 211usize,
        end_col: 57usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_over_interval_pointwise()),
    ),
};
fn cumulative_time_table_over_interval_pointwise() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "pointwise",
            ]),
        ),
        "cumulative_time_table_over_interval_pointwise",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_naive_sequence"]
pub const cumulative_time_table_over_interval_naive_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("cumulative_time_table_over_interval_naive_sequence"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 219usize,
        start_col: 17usize,
        end_line: 219usize,
        end_col: 62usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(cumulative_time_table_over_interval_naive_sequence()),
    ),
};
fn cumulative_time_table_over_interval_naive_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_naive_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_big_step_sequence"]
pub const cumulative_time_table_over_interval_big_step_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_big_step_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 226usize,
        start_col: 17usize,
        end_line: 226usize,
        end_col: 65usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_big_step_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_big_step_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_big_step_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_pointwise_sequence"]
pub const cumulative_time_table_over_interval_pointwise_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_pointwise_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 233usize,
        start_col: 17usize,
        end_line: 233usize,
        end_col: 66usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_pointwise_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_pointwise_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_pointwise_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_naive_sequence_incremental_backtracking"]
pub const cumulative_time_table_over_interval_naive_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_naive_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 241usize,
        start_col: 17usize,
        end_line: 241usize,
        end_col: 87usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_naive_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_naive_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_naive_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_big_step_sequence_incremental_backtracking"]
pub const cumulative_time_table_over_interval_big_step_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_big_step_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 248usize,
        start_col: 17usize,
        end_line: 248usize,
        end_col: 90usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_big_step_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_big_step_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_big_step_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_pointwise_sequence_incremental_backtracking"]
pub const cumulative_time_table_over_interval_pointwise_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_pointwise_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 255usize,
        start_col: 17usize,
        end_line: 255usize,
        end_col: 91usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_pointwise_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_pointwise_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_pointwise_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_naive_incremental_backtracking"]
pub const cumulative_time_table_over_interval_naive_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_naive_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 263usize,
        start_col: 17usize,
        end_line: 263usize,
        end_col: 78usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_naive_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_naive_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_over_interval_naive_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_big_step_incremental_backtracking"]
pub const cumulative_time_table_over_interval_big_step_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_big_step_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 270usize,
        start_col: 17usize,
        end_line: 270usize,
        end_col: 81usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_big_step_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_big_step_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_over_interval_big_step_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_pointwise_incremental_backtracking"]
pub const cumulative_time_table_over_interval_pointwise_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_pointwise_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 277usize,
        start_col: 17usize,
        end_line: 277usize,
        end_col: 82usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_pointwise_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_pointwise_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_over_interval_pointwise_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_naive"]
pub const cumulative_time_table_over_interval_incremental_naive: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_naive",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 197usize,
        start_col: 17usize,
        end_line: 197usize,
        end_col: 53usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_naive(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_naive() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "naive",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_naive",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_big_step"]
pub const cumulative_time_table_over_interval_incremental_big_step: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_big_step",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 204usize,
        start_col: 17usize,
        end_line: 204usize,
        end_col: 56usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_big_step(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_big_step() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "big-step",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_big_step",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_pointwise"]
pub const cumulative_time_table_over_interval_incremental_pointwise: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_pointwise",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 211usize,
        start_col: 17usize,
        end_line: 211usize,
        end_col: 57usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_pointwise(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_pointwise() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "pointwise",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_pointwise",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_naive_sequence"]
pub const cumulative_time_table_over_interval_incremental_naive_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_naive_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 219usize,
        start_col: 17usize,
        end_line: 219usize,
        end_col: 62usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_naive_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_naive_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_naive_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_big_step_sequence"]
pub const cumulative_time_table_over_interval_incremental_big_step_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_big_step_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 226usize,
        start_col: 17usize,
        end_line: 226usize,
        end_col: 65usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_big_step_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_big_step_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_big_step_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_pointwise_sequence"]
pub const cumulative_time_table_over_interval_incremental_pointwise_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_pointwise_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 233usize,
        start_col: 17usize,
        end_line: 233usize,
        end_col: 66usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_pointwise_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_pointwise_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_pointwise_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_naive_sequence_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_naive_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_naive_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 241usize,
        start_col: 17usize,
        end_line: 241usize,
        end_col: 87usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_naive_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_naive_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_naive_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_big_step_sequence_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_big_step_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_big_step_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 248usize,
        start_col: 17usize,
        end_line: 248usize,
        end_col: 90usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_big_step_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_big_step_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_big_step_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_pointwise_sequence_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_pointwise_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_pointwise_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 255usize,
        start_col: 17usize,
        end_line: 255usize,
        end_col: 91usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_pointwise_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_pointwise_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_pointwise_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_naive_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_naive_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_naive_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 263usize,
        start_col: 17usize,
        end_line: 263usize,
        end_col: 78usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_naive_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_naive_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_naive_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_big_step_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_big_step_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_big_step_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 270usize,
        start_col: 17usize,
        end_line: 270usize,
        end_col: 81usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_big_step_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_big_step_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_big_step_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_pointwise_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_pointwise_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_pointwise_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 277usize,
        start_col: 17usize,
        end_line: 277usize,
        end_col: 82usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_pointwise_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_pointwise_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_over_interval_incremental"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_pointwise_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_naive"]
pub const cumulative_time_table_over_interval_incremental_synchronised_naive: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_naive",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 197usize,
        start_col: 17usize,
        end_line: 197usize,
        end_col: 53usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_naive(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_naive() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "naive",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_naive",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_big_step"]
pub const cumulative_time_table_over_interval_incremental_synchronised_big_step: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_big_step",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 204usize,
        start_col: 17usize,
        end_line: 204usize,
        end_col: 56usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_big_step(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_big_step() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "big-step",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_big_step",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_pointwise"]
pub const cumulative_time_table_over_interval_incremental_synchronised_pointwise: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_pointwise",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 211usize,
        start_col: 17usize,
        end_line: 211usize,
        end_col: 57usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_pointwise(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_pointwise() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "pointwise",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_pointwise",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_naive_sequence"]
pub const cumulative_time_table_over_interval_incremental_synchronised_naive_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_naive_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 219usize,
        start_col: 17usize,
        end_line: 219usize,
        end_col: 62usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_naive_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_naive_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_naive_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence"]
pub const cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 226usize,
        start_col: 17usize,
        end_line: 226usize,
        end_col: 65usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence"]
pub const cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 233usize,
        start_col: 17usize,
        end_line: 233usize,
        end_col: 66usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_naive_sequence_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_synchronised_naive_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_naive_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 241usize,
        start_col: 17usize,
        end_line: 241usize,
        end_col: 87usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_naive_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_naive_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_naive_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 248usize,
        start_col: 17usize,
        end_line: 248usize,
        end_col: 90usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 255usize,
        start_col: 17usize,
        end_line: 255usize,
        end_col: 91usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_naive_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_synchronised_naive_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_naive_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 263usize,
        start_col: 17usize,
        end_line: 263usize,
        end_col: 78usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_naive_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_naive_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_naive_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_big_step_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_synchronised_big_step_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_big_step_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 270usize,
        start_col: 17usize,
        end_line: 270usize,
        end_col: 81usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_big_step_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_big_step_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_big_step_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_incremental_synchronised_pointwise_incremental_backtracking"]
pub const cumulative_time_table_over_interval_incremental_synchronised_pointwise_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_incremental_synchronised_pointwise_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 277usize,
        start_col: 17usize,
        end_line: 277usize,
        end_col: 82usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_incremental_synchronised_pointwise_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_over_interval_incremental_synchronised_pointwise_incremental_backtracking() {
    run_mzn_test_with_options::<
        false,
    >(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "time_table_over_interval_incremental_synchronised",
                ),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "cumulative_time_table_over_interval_incremental_synchronised_pointwise_incremental_backtracking",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 14usize,
        start_col: 16usize,
        end_line: 14usize,
        end_col: 77usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "naive",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "naive",
            ]),
        ),
        "< equality_ time_table_per_point _naive >",
        "< equality_ $second _naive >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 27usize,
        start_col: 16usize,
        end_line: 27usize,
        end_col: 80usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "big-step",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "big-step",
            ]),
        ),
        "< equality_ time_table_per_point _big_step >",
        "< equality_ $second _big_step >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 40usize,
        start_col: 16usize,
        end_line: 40usize,
        end_col: 81usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "pointwise",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "pointwise",
            ]),
        ),
        "< equality_ time_table_per_point _pointwise >",
        "< equality_ $second _pointwise >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 54usize,
        start_col: 16usize,
        end_line: 54usize,
        end_col: 86usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "< equality_ time_table_per_point _naive_sequence >",
        "< equality_ $second _naive_sequence >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 67usize,
        start_col: 16usize,
        end_line: 67usize,
        end_col: 89usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "< equality_ time_table_per_point _big_step_sequence >",
        "< equality_ $second _big_step_sequence >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 80usize,
        start_col: 16usize,
        end_line: 80usize,
        end_col: 90usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "< equality_ time_table_per_point _pointwise_sequence >",
        "< equality_ $second _pointwise_sequence >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 94usize,
        start_col: 16usize,
        end_line: 94usize,
        end_col: 111usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "< equality_ time_table_per_point _naive_sequence_incremental_backtracking >",
        "< equality_ $second _naive_sequence_incremental_backtracking >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 107usize,
        start_col: 16usize,
        end_line: 107usize,
        end_col: 114usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "< equality_ time_table_per_point _big_step_sequence_incremental_backtracking >",
        "< equality_ $second _big_step_sequence_incremental_backtracking >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 120usize,
        start_col: 16usize,
        end_line: 120usize,
        end_col: 115usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "< equality_ time_table_per_point _pointwise_sequence_incremental_backtracking\n>",
        "< equality_ $second _pointwise_sequence_incremental_backtracking >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_incremental_backtracking"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 134usize,
        start_col: 16usize,
        end_line: 134usize,
        end_col: 102usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_incremental_backtracking() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "< equality_ time_table_per_point _naive_incremental_backtracking >",
        "< equality_ $second _naive_incremental_backtracking >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 147usize,
        start_col: 16usize,
        end_line: 147usize,
        end_col: 105usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "< equality_ time_table_per_point _big_step_incremental_backtracking >",
        "< equality_ $second _big_step_incremental_backtracking >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking"]
pub const cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 160usize,
        start_col: 16usize,
        end_line: 160usize,
        end_col: 106usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking(),
        ),
    ),
};
fn cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("time_table_per_point_incremental_synchronised"),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-incremental-backtracking",
            ]),
        ),
        "< equality_ time_table_per_point _pointwise_incremental_backtracking >",
        "< equality_ $second _pointwise_incremental_backtracking >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_naive_generate_sequence"]
pub const cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_naive_generate_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_naive_generate_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 339usize,
        start_col: 1usize,
        end_line: 342usize,
        end_col: 2usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_naive_generate_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_naive_generate_sequence() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("\"time_table_over_interval\""),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "\"time_table_over_interval_incremental_synchronised\"",
                ),
                "--cumulative-explanation-type",
                "naive",
                "--cumulative-generate-sequence",
            ]),
        ),
        "< equality_ \"time_table_over_interval\" _ \"naive\" _ \"generate_sequence\" >",
        "< equality_ $second _ \"naive\" _ \"generate_sequence\" >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_big_step_generate_sequence"]
pub const cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_big_step_generate_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_big_step_generate_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 339usize,
        start_col: 1usize,
        end_line: 342usize,
        end_col: 2usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_big_step_generate_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_big_step_generate_sequence() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("\"time_table_over_interval\""),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "\"time_table_over_interval_incremental_synchronised\"",
                ),
                "--cumulative-explanation-type",
                "big-step",
                "--cumulative-generate-sequence",
            ]),
        ),
        "< equality_ \"time_table_over_interval\" _ \"big-step\" _ \"generate_sequence\" >",
        "< equality_ $second _ \"big-step\" _ \"generate_sequence\" >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_pointwise_generate_sequence"]
pub const cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_pointwise_generate_sequence: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName(
            "cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_pointwise_generate_sequence",
        ),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 339usize,
        start_col: 1usize,
        end_line: 342usize,
        end_col: 2usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(
            cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_pointwise_generate_sequence(),
        ),
    ),
};
fn cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_pointwise_generate_sequence() {
    check_statistic_equality(
        "cumulative",
        "mzn_constraints",
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case("\"time_table_over_interval\""),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                "--cumulative-propagation-method",
                &stringcase::kebab_case(
                    "\"time_table_over_interval_incremental_synchronised\"",
                ),
                "--cumulative-explanation-type",
                "pointwise",
                "--cumulative-generate-sequence",
            ]),
        ),
        "< equality_ \"time_table_over_interval\" _ \"pointwise\" _ \"generate_sequence\" >",
        "< equality_ $second _ \"pointwise\" _ \"generate_sequence\" >",
    );
}
extern crate test;
#[cfg(test)]
#[rustc_test_marker = "all_different"]
pub const all_different: test::TestDescAndFn = test::TestDescAndFn {
    desc: test::TestDesc {
        name: test::StaticTestName("all_different"),
        ignore: false,
        ignore_message: ::core::option::Option::None,
        source_file: "pumpkin-solver/tests/mzn_constraint_test.rs",
        start_line: 344usize,
        start_col: 11usize,
        end_line: 344usize,
        end_col: 24usize,
        compile_fail: false,
        no_run: false,
        should_panic: test::ShouldPanic::No,
        test_type: test::TestType::IntegrationTest,
    },
    testfn: test::StaticTestFn(
        #[coverage(off)]
        || test::assert_test_result(all_different()),
    ),
};
fn all_different() {
    run_mzn_test_with_options::<
        false,
    >("all_different", "mzn_constraints", ::alloc::vec::Vec::new(), "all_different");
}
#[rustc_main]
#[coverage(off)]
pub fn main() -> () {
    extern crate test;
    test::test_main_static(
        &[
            &all_different,
            &array_int_maximum,
            &array_int_minimum,
            &bool_clause,
            &bool_lin_eq,
            &bool_lin_le,
            &bool_not,
            &bool_xor,
            &bool_xor_reif,
            &cumulative_time_table_over_interval_big_step,
            &cumulative_time_table_over_interval_big_step_incremental_backtracking,
            &cumulative_time_table_over_interval_big_step_sequence,
            &cumulative_time_table_over_interval_big_step_sequence_incremental_backtracking,
            &cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_big_step_generate_sequence,
            &cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_naive_generate_sequence,
            &cumulative_time_table_over_interval_equal_with_time_table_over_interval_incremental_synchronised_pointwise_generate_sequence,
            &cumulative_time_table_over_interval_incremental_big_step,
            &cumulative_time_table_over_interval_incremental_big_step_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_big_step_sequence,
            &cumulative_time_table_over_interval_incremental_big_step_sequence_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_naive,
            &cumulative_time_table_over_interval_incremental_naive_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_naive_sequence,
            &cumulative_time_table_over_interval_incremental_naive_sequence_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_pointwise,
            &cumulative_time_table_over_interval_incremental_pointwise_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_pointwise_sequence,
            &cumulative_time_table_over_interval_incremental_pointwise_sequence_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_synchronised_big_step,
            &cumulative_time_table_over_interval_incremental_synchronised_big_step_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence,
            &cumulative_time_table_over_interval_incremental_synchronised_big_step_sequence_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_synchronised_naive,
            &cumulative_time_table_over_interval_incremental_synchronised_naive_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_synchronised_naive_sequence,
            &cumulative_time_table_over_interval_incremental_synchronised_naive_sequence_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_synchronised_pointwise,
            &cumulative_time_table_over_interval_incremental_synchronised_pointwise_incremental_backtracking,
            &cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence,
            &cumulative_time_table_over_interval_incremental_synchronised_pointwise_sequence_incremental_backtracking,
            &cumulative_time_table_over_interval_naive,
            &cumulative_time_table_over_interval_naive_incremental_backtracking,
            &cumulative_time_table_over_interval_naive_sequence,
            &cumulative_time_table_over_interval_naive_sequence_incremental_backtracking,
            &cumulative_time_table_over_interval_pointwise,
            &cumulative_time_table_over_interval_pointwise_incremental_backtracking,
            &cumulative_time_table_over_interval_pointwise_sequence,
            &cumulative_time_table_over_interval_pointwise_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_big_step,
            &cumulative_time_table_per_point_big_step_incremental_backtracking,
            &cumulative_time_table_per_point_big_step_sequence,
            &cumulative_time_table_per_point_big_step_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_incremental_backtracking,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence,
            &cumulative_time_table_per_point_equal_with_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_big_step,
            &cumulative_time_table_per_point_incremental_big_step_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_big_step_sequence,
            &cumulative_time_table_per_point_incremental_big_step_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_naive,
            &cumulative_time_table_per_point_incremental_naive_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_naive_sequence,
            &cumulative_time_table_per_point_incremental_naive_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_pointwise,
            &cumulative_time_table_per_point_incremental_pointwise_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_pointwise_sequence,
            &cumulative_time_table_per_point_incremental_pointwise_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_synchronised_big_step,
            &cumulative_time_table_per_point_incremental_synchronised_big_step_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_synchronised_big_step_sequence,
            &cumulative_time_table_per_point_incremental_synchronised_big_step_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_synchronised_naive,
            &cumulative_time_table_per_point_incremental_synchronised_naive_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_synchronised_naive_sequence,
            &cumulative_time_table_per_point_incremental_synchronised_naive_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_synchronised_pointwise,
            &cumulative_time_table_per_point_incremental_synchronised_pointwise_incremental_backtracking,
            &cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence,
            &cumulative_time_table_per_point_incremental_synchronised_pointwise_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_naive,
            &cumulative_time_table_per_point_naive_incremental_backtracking,
            &cumulative_time_table_per_point_naive_sequence,
            &cumulative_time_table_per_point_naive_sequence_incremental_backtracking,
            &cumulative_time_table_per_point_pointwise,
            &cumulative_time_table_per_point_pointwise_incremental_backtracking,
            &cumulative_time_table_per_point_pointwise_sequence,
            &cumulative_time_table_per_point_pointwise_sequence_incremental_backtracking,
            &int_abs,
            &int_div,
            &int_eq,
            &int_eq_reif,
            &int_le,
            &int_le_reif,
            &int_lin_eq,
            &int_lin_eq_reif,
            &int_lin_le,
            &int_lin_le_reif,
            &int_lin_ne,
            &int_lin_ne_reif,
            &int_lt,
            &int_lt_reif,
            &int_max,
            &int_min,
            &int_mod,
            &int_ne,
            &int_ne_reif,
            &int_plus,
            &int_times,
            &set_in,
            &set_in_reif_interval,
            &set_in_reif_sparse,
        ],
    )
}
