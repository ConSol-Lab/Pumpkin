mod linear;
mod nogood;

use crate::model::Atomic;
use crate::model::Model;

pub(crate) struct Fact {
    pub(crate) premises: Vec<Atomic>,
    pub(crate) consequent: Option<Atomic>,
}

#[derive(Clone, Copy, thiserror::Error, Debug)]
#[error("invalid inference")]
pub enum InvalidInference {
    #[error("inference does not have a label")]
    MissingLabel,

    #[error("inference is not supported")]
    UnsupportedLabel,

    #[error("indicated constraint cannot generate inferences with the indicated label")]
    ConstraintLabelMismatch,

    #[error("generated by undefined constraint")]
    UndefinedConstraint,

    #[error("missing constraint hint")]
    MissingConstraint,

    #[error("inconsistent premises")]
    InconsistentPremises,

    #[error("inference is unsound")]
    Unsound,
}

pub(crate) fn verify_inference(
    model: &Model,
    inference: &drcp_format::Inference<std::rc::Rc<str>, i32, std::rc::Rc<str>>,
) -> Result<Fact, InvalidInference> {
    match inference.label.as_ref().map(|label| label.as_ref()) {
        Some("linear_bounds") => {
            let generated_by = inference
                .generated_by
                .ok_or(InvalidInference::MissingConstraint)?;

            linear::verify_linear_bounds(
                model,
                &inference.premises,
                inference.consequent.clone(),
                generated_by,
            )
        }

        Some("nogood") => {
            let generated_by = inference
                .generated_by
                .ok_or(InvalidInference::MissingConstraint)?;

            nogood::verify_nogood(
                model,
                &inference.premises,
                inference.consequent.clone(),
                generated_by,
            )
        }

        Some("initial_domain") => {
            let Some(atomic) = inference.consequent.clone() else {
                return Err(InvalidInference::Unsound);
            };

            if model.is_trivially_true(atomic.clone()) {
                Ok(Fact {
                    premises: vec![],
                    consequent: Some(atomic),
                })
            } else {
                Err(InvalidInference::Unsound)
            }
        }

        None => Err(InvalidInference::MissingLabel),
        Some(_) => Err(InvalidInference::UnsupportedLabel),
    }
}
