mod all_different;
mod arithmetic;
mod linear;
mod nogood;
mod time_table;

use crate::model::Atomic;
use crate::model::Model;

#[derive(Clone, Debug)]
pub struct Fact {
    pub premises: Vec<Atomic>,
    pub consequent: Option<Atomic>,
}

impl Fact {
    /// Create a fact `premises -> false`.
    pub fn nogood(premises: Vec<Atomic>) -> Self {
        Fact {
            premises,
            consequent: None,
        }
    }
}

#[derive(Clone, Copy, thiserror::Error, Debug)]
#[error("invalid inference")]
pub enum InvalidInference {
    #[error("inference does not have a label")]
    MissingLabel,

    #[error("inference is not supported")]
    UnsupportedLabel,

    #[error("indicated constraint cannot generate inferences with the indicated label")]
    ConstraintLabelMismatch,

    #[error("generated by undefined constraint")]
    UndefinedConstraint,

    #[error("missing constraint hint")]
    MissingConstraint,

    #[error("inconsistent premises")]
    InconsistentPremises,

    #[error("inference is unsound")]
    Unsound,
}

pub(crate) fn verify_inference(
    model: &Model,
    inference: &drcp_format::Inference<std::rc::Rc<str>, i32, std::rc::Rc<str>>,
) -> Result<Fact, InvalidInference> {
    let fact = Fact {
        premises: inference.premises.clone(),
        consequent: inference.consequent.clone(),
    };

    let label = inference
        .label
        .as_ref()
        .map(|label| label.as_ref())
        .ok_or(InvalidInference::MissingLabel)?;

    // The initial domain inference is handled separately since it is the only inference that
    // does not expect a constraint hint.
    if label == "initial_domain" {
        let Some(atomic) = inference.consequent.clone() else {
            // The initial domain inference requires a consequent.
            return Err(InvalidInference::Unsound);
        };

        if !model.is_trivially_true(atomic.clone()) {
            // If the consequent is not trivially true in the model then the inference
            // is unsound.
            return Err(InvalidInference::Unsound);
        }

        return Ok(fact);
    }

    // Get the constraint that generated the inference from the model.
    let generated_by_constraint_id = inference
        .generated_by
        .ok_or(InvalidInference::MissingConstraint)?;
    let generated_by = model
        .get_constraint(generated_by_constraint_id)
        .ok_or(InvalidInference::MissingConstraint)?;

    match label {
        "linear_bounds" => {
            linear::verify_linear_bounds(&fact, generated_by)?;
        }

        "nogood" => {
            nogood::verify_nogood(&fact, generated_by)?;
        }

        "time_table" => {
            time_table::verify_time_table(&fact, generated_by)?;
        }

        "all_different" => {
            all_different::verify_all_different(&fact, generated_by)?;
        }

        "binary_equals" => {
            arithmetic::verify_binary_equals(&fact, generated_by)?;
        }

        "binary_not_equals" => {
            arithmetic::verify_binary_not_equals(&fact, generated_by)?;
        }

        _ => return Err(InvalidInference::UnsupportedLabel),
    }

    Ok(fact)
}
